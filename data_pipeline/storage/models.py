"""
Database models for trading data using SQLAlchemy ORM
Optimized for TimescaleDB time-series queries with composite primary keys
"""
from sqlalchemy import Column, String, Float, DateTime, Integer, Index, UniqueConstraint, PrimaryKeyConstraint
from sqlalchemy.dialects.postgresql import JSONB
from datetime import datetime
from data_pipeline.storage.database import Base


class MarketData(Base):
    """
    OHLCV market data model
    Optimized for time-series queries with TimescaleDB hypertable
    Uses composite primary key including timestamp for TimescaleDB compatibility
    """
    __tablename__ = 'market_data'
    
    # Composite primary key with timestamp (required for TimescaleDB)
    id = Column(Integer, autoincrement=True)
    timestamp = Column(DateTime(timezone=True), nullable=False)
    
    # Symbol information
    symbol = Column(String(20), nullable=False)
    exchange = Column(String(20), default='US')
    
    # OHLCV data
    open = Column(Float, nullable=False)
    high = Column(Float, nullable=False)
    low = Column(Float, nullable=False)
    close = Column(Float, nullable=False)
    volume = Column(Float, nullable=False)
    
    # Additional market data
    vwap = Column(Float)  # Volume-weighted average price
    trades = Column(Integer)  # Number of trades
    
    # Metadata
    interval = Column(String(10), nullable=False)  # 1m, 5m, 1h, 1d, etc.
    source = Column(String(50), default='yfinance')
    created_at = Column(DateTime(timezone=True), default=datetime.utcnow)
    
    # Additional data (flexible JSON field)
    extra_data = Column(JSONB, default={})
    
    # Composite primary key including timestamp (required for TimescaleDB partitioning)
    __table_args__ = (
        PrimaryKeyConstraint('id', 'timestamp'),
        UniqueConstraint('symbol', 'timestamp', 'interval', name='uq_symbol_timestamp_interval'),
        Index('idx_symbol_timestamp', 'symbol', 'timestamp'),
        Index('idx_timestamp_symbol', 'timestamp', 'symbol'),
        Index('idx_symbol_interval', 'symbol', 'interval'),
    )
    
    def __repr__(self):
        return f"<MarketData(symbol={self.symbol}, timestamp={self.timestamp}, close={self.close})>"
    
    def to_dict(self):
        """Convert to dictionary for JSON serialization"""
        return {
            'id': self.id,
            'timestamp': self.timestamp.isoformat() if self.timestamp else None,
            'symbol': self.symbol,
            'exchange': self.exchange,
            'open': self.open,
            'high': self.high,
            'low': self.low,
            'close': self.close,
            'volume': self.volume,
            'vwap': self.vwap,
            'trades': self.trades,
            'interval': self.interval,
            'source': self.source,
            'extra_data': self.extra_data
        }


class TradingSignal(Base):
    """
    Trading signals generated by strategies
    Stores BUY/SELL/HOLD recommendations with confidence scores
    """
    __tablename__ = 'trading_signals'
    
    # Composite primary key with timestamp
    id = Column(Integer, autoincrement=True)
    timestamp = Column(DateTime(timezone=True), nullable=False)
    
    # Signal information
    symbol = Column(String(20), nullable=False)
    strategy = Column(String(100), nullable=False)
    signal_type = Column(String(20), nullable=False)  # BUY, SELL, HOLD
    strength = Column(Float)  # Signal strength/confidence 0-1
    
    # Price and context
    price = Column(Float)
    target_price = Column(Float)
    stop_loss = Column(Float)
    expected_return = Column(Float)
    risk_reward_ratio = Column(Float)
    
    # Additional data
    extra_data = Column(JSONB, default={})
    created_at = Column(DateTime(timezone=True), default=datetime.utcnow)
    
    __table_args__ = (
        PrimaryKeyConstraint('id', 'timestamp'),
        Index('idx_signal_timestamp', 'timestamp'),
        Index('idx_signal_symbol', 'symbol', 'timestamp'),
        Index('idx_signal_strategy', 'strategy', 'timestamp'),
    )
    
    def __repr__(self):
        return f"<TradingSignal(symbol={self.symbol}, type={self.signal_type}, strength={self.strength})>"
    
    def to_dict(self):
        return {
            'id': self.id,
            'timestamp': self.timestamp.isoformat() if self.timestamp else None,
            'symbol': self.symbol,
            'strategy': self.strategy,
            'signal_type': self.signal_type,
            'strength': self.strength,
            'price': self.price,
            'target_price': self.target_price,
            'stop_loss': self.stop_loss,
            'extra_data': self.extra_data
        }


class Trade(Base):
    """
    Executed trades with full audit trail
    Tracks orders from submission to execution/cancellation
    """
    __tablename__ = 'trades'
    
    # Composite primary key with timestamp
    id = Column(Integer, autoincrement=True)
    timestamp = Column(DateTime(timezone=True), nullable=False)
    
    # Trade details
    symbol = Column(String(20), nullable=False)
    side = Column(String(10), nullable=False)  # BUY or SELL
    quantity = Column(Float, nullable=False)
    price = Column(Float, nullable=False)
    
    # Execution details
    order_type = Column(String(20))  # MARKET, LIMIT, STOP, STOP_LIMIT
    status = Column(String(20), default='PENDING')  # PENDING, FILLED, CANCELLED, REJECTED
    strategy = Column(String(100))
    
    # Order IDs for tracking
    order_id = Column(String(100))
    exchange_order_id = Column(String(100))
    
    # Cost analysis
    commission = Column(Float, default=0)
    slippage = Column(Float, default=0)
    total_cost = Column(Float)
    
    # P&L tracking (for closed positions)
    entry_price = Column(Float)
    exit_price = Column(Float)
    realized_pnl = Column(Float)
    unrealized_pnl = Column(Float)
    
    # Risk management
    stop_loss = Column(Float)
    take_profit = Column(Float)
    
    # Additional data
    extra_data = Column(JSONB, default={})
    created_at = Column(DateTime(timezone=True), default=datetime.utcnow)
    updated_at = Column(DateTime(timezone=True), onupdate=datetime.utcnow)
    filled_at = Column(DateTime(timezone=True))
    
    __table_args__ = (
        PrimaryKeyConstraint('id', 'timestamp'),
        UniqueConstraint('order_id', 'timestamp', name='uq_order_timestamp'),
        Index('idx_trade_timestamp', 'timestamp'),
        Index('idx_trade_symbol', 'symbol', 'timestamp'),
        Index('idx_trade_status', 'status'),
        Index('idx_trade_strategy', 'strategy'),
    )
    
    def __repr__(self):
        return f"<Trade(symbol={self.symbol}, side={self.side}, qty={self.quantity}, price={self.price})>"
    
    def to_dict(self):
        return {
            'id': self.id,
            'timestamp': self.timestamp.isoformat() if self.timestamp else None,
            'symbol': self.symbol,
            'side': self.side,
            'quantity': self.quantity,
            'price': self.price,
            'order_type': self.order_type,
            'status': self.status,
            'strategy': self.strategy,
            'order_id': self.order_id,
            'commission': self.commission,
            'slippage': self.slippage,
            'total_cost': self.total_cost,
            'realized_pnl': self.realized_pnl,
            'extra_data': self.extra_data
        }


class Position(Base):
    """
    Current open positions
    Tracks holdings and P&L for active positions
    NOTE: This is not a hypertable, just a regular table
    """
    __tablename__ = 'positions'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    
    # Position details
    symbol = Column(String(20), nullable=False, unique=True, index=True)
    quantity = Column(Float, nullable=False)
    average_entry_price = Column(Float, nullable=False)
    current_price = Column(Float)
    
    # P&L
    unrealized_pnl = Column(Float)
    unrealized_pnl_percent = Column(Float)
    total_cost = Column(Float)
    market_value = Column(Float)
    
    # Risk metrics
    max_drawdown = Column(Float)
    peak_value = Column(Float)
    
    # Strategy info
    strategy = Column(String(100))
    
    # Additional data
    extra_data = Column(JSONB, default={})
    opened_at = Column(DateTime(timezone=True), default=datetime.utcnow)
    updated_at = Column(DateTime(timezone=True), onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<Position(symbol={self.symbol}, qty={self.quantity}, entry={self.average_entry_price})>"
    
    def to_dict(self):
        return {
            'id': self.id,
            'symbol': self.symbol,
            'quantity': self.quantity,
            'average_entry_price': self.average_entry_price,
            'current_price': self.current_price,
            'unrealized_pnl': self.unrealized_pnl,
            'unrealized_pnl_percent': self.unrealized_pnl_percent,
            'market_value': self.market_value,
            'strategy': self.strategy,
            'opened_at': self.opened_at.isoformat() if self.opened_at else None,
        }
